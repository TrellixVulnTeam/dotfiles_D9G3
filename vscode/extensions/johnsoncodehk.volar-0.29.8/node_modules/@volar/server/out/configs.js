"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLsConfigs = void 0;
const tsConfigs = require("./tsConfigs");
const shared = require("@volar/shared");
function createLsConfigs(rootFolders, connection) {
    let emmetConfig;
    let tsPreferences = {};
    let tsFormatOptions = {};
    let cssLanguageSettings = {};
    let htmlHoverSettings = {};
    let codeLensConfigs;
    let htmlCustomData;
    let cssCustomData;
    const vueLsArr = [];
    connection.onDidChangeConfiguration(async () => {
        emmetConfig = undefined;
        codeLensConfigs = undefined;
        tsPreferences = {};
        tsFormatOptions = {};
        cssLanguageSettings = {};
        htmlHoverSettings = {};
        htmlCustomData = undefined;
        cssCustomData = undefined;
        for (const vueLs of vueLsArr) {
            vueLs.updateHtmlCustomData(await getHtmlCustomData());
            vueLs.updateCssCustomData(await getCssCustomData());
        }
    });
    return {
        getCodeLensConfigs,
        getEmmetConfiguration,
        getCssLanguageSettings,
        getTsPreferences,
        getTsFormatOptions,
        getHtmlHoverSettings,
        registerCustomData,
    };
    async function registerCustomData(vueLs) {
        vueLsArr.push(vueLs);
        vueLs.updateHtmlCustomData(await getHtmlCustomData());
        vueLs.updateCssCustomData(await getCssCustomData());
    }
    async function getHtmlCustomData() {
        var _a;
        if (!htmlCustomData) {
            const paths = new Set();
            const customData = (_a = await connection.workspace.getConfiguration({ section: 'html.customData' })) !== null && _a !== void 0 ? _a : [];
            const rootPaths = rootFolders.map(shared.uriToFsPath);
            for (const customDataPath of customData) {
                try {
                    const jsonPath = require.resolve(customDataPath, { paths: rootPaths });
                    paths.add(jsonPath);
                }
                catch (error) {
                    console.error(error);
                }
            }
            htmlCustomData = {};
            for (const path of paths) {
                try {
                    htmlCustomData[path] = require(path);
                }
                catch (error) {
                    console.error(error);
                }
            }
        }
        return htmlCustomData;
    }
    async function getCssCustomData() {
        var _a;
        if (!cssCustomData) {
            const paths = new Set();
            const customData = (_a = await connection.workspace.getConfiguration({ section: 'css.customData' })) !== null && _a !== void 0 ? _a : [];
            const rootPaths = rootFolders.map(shared.uriToFsPath);
            for (const customDataPath of customData) {
                try {
                    const jsonPath = require.resolve(customDataPath, { paths: rootPaths });
                    paths.add(jsonPath);
                }
                catch (error) {
                    console.error(error);
                }
            }
            cssCustomData = [];
            for (const path of paths) {
                try {
                    cssCustomData.push(require(path));
                }
                catch (error) {
                    console.error(error);
                }
            }
        }
        return cssCustomData;
    }
    async function getHtmlHoverSettings(textDocument) {
        if (!htmlHoverSettings[textDocument.uri]) {
            htmlHoverSettings[textDocument.uri] = (async () => { var _a; return (_a = await connection.workspace.getConfiguration({ scopeUri: textDocument.uri, section: 'html.hover' })) !== null && _a !== void 0 ? _a : {}; })();
        }
        return htmlHoverSettings[textDocument.uri];
    }
    function getTsPreferences(textDocument) {
        var _a;
        return (_a = tsPreferences[textDocument.uri]) !== null && _a !== void 0 ? _a : (tsPreferences[textDocument.uri] = tsConfigs.getPreferences(connection.workspace, textDocument));
    }
    function getTsFormatOptions(textDocument, options) {
        var _a;
        return (_a = tsFormatOptions[textDocument.uri]) !== null && _a !== void 0 ? _a : (tsFormatOptions[textDocument.uri] = tsConfigs.getFormatOptions(connection.workspace, textDocument, options));
    }
    function getCssLanguageSettings(textDocument) {
        if (!cssLanguageSettings[textDocument.uri]) {
            cssLanguageSettings[textDocument.uri] = (async () => await connection.workspace.getConfiguration({ scopeUri: textDocument.uri, section: textDocument.languageId }))();
        }
        return cssLanguageSettings[textDocument.uri];
    }
    async function getCodeLensConfigs() {
        if (!codeLensConfigs) {
            const [codeLensReferences, codeLensPugTool, codeLensRefScriptSetupTool,] = await Promise.all([
                connection.workspace.getConfiguration('volar.codeLens.references'),
                connection.workspace.getConfiguration('volar.codeLens.pugTools'),
                connection.workspace.getConfiguration('volar.codeLens.scriptSetupTools'),
            ]);
            codeLensConfigs = {
                references: !!codeLensReferences,
                pugTool: !!codeLensPugTool,
                scriptSetupTool: !!codeLensRefScriptSetupTool,
            };
        }
        return codeLensConfigs;
    }
    async function getEmmetConfiguration(syntax) {
        var _a;
        if (!emmetConfig) {
            emmetConfig = (_a = (await connection.workspace.getConfiguration('emmet'))) !== null && _a !== void 0 ? _a : {};
        }
        const syntaxProfiles = Object.assign({}, emmetConfig['syntaxProfiles'] || {});
        const preferences = Object.assign({}, emmetConfig['preferences'] || {});
        // jsx, xml and xsl syntaxes need to have self closing tags unless otherwise configured by user
        if (syntax === 'jsx' || syntax === 'xml' || syntax === 'xsl') {
            syntaxProfiles[syntax] = syntaxProfiles[syntax] || {};
            if (typeof syntaxProfiles[syntax] === 'object'
                && !syntaxProfiles[syntax].hasOwnProperty('self_closing_tag') // Old Emmet format
                && !syntaxProfiles[syntax].hasOwnProperty('selfClosingStyle') // Emmet 2.0 format
            ) {
                syntaxProfiles[syntax] = {
                    ...syntaxProfiles[syntax],
                    selfClosingStyle: 'xml'
                };
            }
        }
        return {
            preferences,
            showExpandedAbbreviation: emmetConfig['showExpandedAbbreviation'],
            showAbbreviationSuggestions: emmetConfig['showAbbreviationSuggestions'],
            syntaxProfiles,
            variables: emmetConfig['variables'],
            excludeLanguages: emmetConfig['excludeLanguages'],
            showSuggestionsAsSnippets: emmetConfig['showSuggestionsAsSnippets']
        };
    }
}
exports.createLsConfigs = createLsConfigs;
//# sourceMappingURL=configs.js.map